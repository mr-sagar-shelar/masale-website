<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Masale on Langium</title><link>/</link><description>Recent content in Masale on Langium</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 17 Nov 2021 14:06:59 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Validation</title><link>/docs/learn/minilogo/validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/minilogo/validation/</guid><description>Overview The Validation Registry Finding Nodes to Validate Registering Validations In this tutorial, we will be talking about implementing validation for your Langium-based language. We recommend first reading the previous tutorial about writing a grammar, as we will assume you&amp;rsquo;re familiar with the topics covered there. We&amp;rsquo;ll also assume that you have a working language to add validation to, so double check that npm run langium:generate succeeds without errors before you proceed.</description></item><item><title>Customizing the CLI</title><link>/docs/learn/minilogo/customizing_cli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/minilogo/customizing_cli/</guid><description>Overview About the Command Line Interface Adding a Parse and Validate Action Building and Running the CLI In this tutorial, we&amp;rsquo;ll be talking about customizing the command line interface for your language. We recommend reading through previous tutorials about writing a grammar and validation. Once you have a good grasp on those concepts, then you should be all set for setting up a CLI.</description></item><item><title>Generation</title><link>/docs/learn/minilogo/generation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/minilogo/generation/</guid><description>Setting up the Generator API Deciding Output to Generate Generating from Statements Writing an Expression Evaluator Generating from Statements with the Evaluator Connecting the Generator to the CLI In this tutorial we&amp;rsquo;ll be showing how to implement basic generation for your language. When we&amp;rsquo;re talking about generation, we&amp;rsquo;re talking about transforming an AST from your Langium-based language into some output target. This could be another language of similar functionality (transpilation), a lower level language (compilation), or generating some artifacts/data that will be consumed by another application.</description></item><item><title>Langium + Monaco Editor</title><link>/docs/learn/minilogo/langium_and_monaco/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/minilogo/langium_and_monaco/</guid><description>Technologies You&amp;rsquo;ll Need Getting your Language Setup for the Web Factoring out File System Dependencies Setting up Monaco Setting up a Static Page Serving via NodeJS Updated on Oct. 4th, 2023 for usage with monaco-editor-wrapper 3.1.0 &amp;amp; above, as well as Langium 2.0.2
In this tutorial we&amp;rsquo;ll be talking about running Langium in the web with the Monaco editor. If you&amp;rsquo;re not familiar with Monaco, it&amp;rsquo;s the editor that powers VS Code.</description></item><item><title>Generation in the Web</title><link>/docs/learn/minilogo/generation_in_the_web/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/minilogo/generation_in_the_web/</guid><description>Handling Document Validations Listening for Notifications in the Client Interpreting Draw Commands (Drawing) Updated on Oct. 4th, 2023 for usage with monaco-editor-wrapper 3.1.0 &amp;amp; above.
In this tutorial we&amp;rsquo;ll be talking about how to perform generation in the web by listening for document builder notifications. There are multiple ways to hook into Langium to utilize the generator, such as by directly exporting the generator API.</description></item><item><title>Glossary</title><link>/docs/reference/glossary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/reference/glossary/</guid><description>Anyone who is new to DSL development should carefully read the following primer on the terms we are using in our documentation:
abstract syntax tree: A tree of elements that represents a text document. Each element is a simple JS object that combines multiple input tokens into a single object. Commonly abbreviated as AST.
document: An abstract term to refer to a text file on your file system or an open editor document in your IDE.</description></item><item><title>Case-insensitive languages</title><link>/docs/recipes/lexing/case-insensitive-languages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/recipes/lexing/case-insensitive-languages/</guid><description>Some programming languages such as SQL or Structured Text use case insensitivity to provide more flexibility when writing code. For example most SQL databases accept select statements starting with select, SELECT or even SeLeCt.
In case you want to provide your users the same flexibility with your language, there are different levels of case-insensitivity in Langium:
You can make Langium&amp;rsquo;s parser completely case insensitive using the language configuration You can include case-insensitivity for specific terminal rules You can make cross references case insensitive All of these options can be enabled independent of one another.</description></item><item><title>Cloud Storage Service (e.g., Google Drive, Dropbox)</title><link>/showcase/cloud-storage-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/cloud-storage-service/</guid><description/></item><item><title>Grammar Language</title><link>/docs/reference/grammar-language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/reference/grammar-language/</guid><description>Language Declaration Import of other grammar languages Terminal Rules Return Types Hidden Terminal Rules Parser Rules Declaration The Entry Rule Extended Backus-Naur Form Expressions Cardinalities Groups Alternatives Keywords Assignments Cross-References Unassigned Rule Calls Unordered Groups Simple Actions Tree-Rewriting Actions Data Type Rules Rule Fragments Guard Conditions More Examples More on Terminal Rules Extended Backus-Naur Form Terminals Terminal Groups Terminal Alternatives Character Range Wildcard Token Until Token Negated Token Terminal Rule Calls Terminal Fragments The grammar language describes the syntax and structure of your language.</description></item><item><title>Qualified Name Scoping</title><link>/docs/recipes/scoping/qualified-name/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/recipes/scoping/qualified-name/</guid><description>Qualified name scoping refers to a style of referencing elements using a fully qualified name. Such a fully qualified name is usually composed of the original name of the target element and the names of its container elements. You will usually see this method of scoping in C-like languages using namespaces or in Java using packages. The following code snippet shows an example of how qualified name scoping works from an end-user perspective, by using a function in a C++ namespace:</description></item><item><title>E-commerce Platform (e.g., Amazon, eBay)</title><link>/showcase/e-commerce-platform/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/e-commerce-platform/</guid><description/></item><item><title>Job Search Platform (e.g., LinkedIn, Indeed)</title><link>/showcase/job-search-platform/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/job-search-platform/</guid><description/></item><item><title>Online Food Delivery Platform (e.g., DoorDash, UberEats)</title><link>/showcase/online-food-delivery-platform/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/online-food-delivery-platform/</guid><description/></item><item><title>Online Learning Platform (e.g., Coursera, Udemy)</title><link>/showcase/online-learning-platform/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/online-learning-platform/</guid><description/></item><item><title>Online Payment System (e.g., PayPal, Stripe)</title><link>/showcase/online-payment-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/online-payment-system/</guid><description/></item><item><title>Real-Time Chat Application (e.g., WhatsApp, Slack)</title><link>/showcase/real-time-chat-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/real-time-chat-application/</guid><description/></item><item><title>Ride-Sharing App (e.g., Uber, Lyft)</title><link>/showcase/ride-sharing-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/ride-sharing-app/</guid><description/></item><item><title>Social Media Platform (e.g., Facebook, Instagram)</title><link>/showcase/social-media-platform/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/social-media-platform/</guid><description/></item><item><title>Video Streaming Service (e.g., Netflix, Hulu)</title><link>/showcase/video-streaming-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/video-streaming-service/</guid><description/></item><item><title>1. Install Yeoman</title><link>/docs/learn/workflow/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/workflow/install/</guid><description>Before diving into Langium itself, let&amp;rsquo;s get your environment ready for development:
You have a working Node environment with version 16 or higher. Install Yeoman and the Langium extension generator. npm i -g yo generator-langium For our getting started example, we would also recommend you to install the latest version of vscode.</description></item><item><title>Builtin Libraries</title><link>/docs/recipes/builtin-library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/recipes/builtin-library/</guid><description>Languages usually offer their users some high-level programming features that they do not have to define themselves. For example, TypeScript provides users with typings for globally accessible variables such as the window, process or console objects. They are part of the JavaScript runtime, and not defined by any user or a package they might import. Instead, these features are contributed through what we call builtin libraries.
Loading a builtin library in Langium is very simple.</description></item><item><title>Class Member Scoping</title><link>/docs/recipes/scoping/class-member/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/recipes/scoping/class-member/</guid><description>In this guide we will take a look at member based scoping. It&amp;rsquo;s a mechanism you are likely familiar with from object oriented languages such as Java, C# and JavaScript:
class A { b: B; } class B { value: string; } function test(): void { const a = new A(); const b = a.b; // Refers to the `b` defined in class `A` const value = b.value; // Refers to the `value` defined in class `B` } Member based scoping like this requires not only a modification of the default scoping provider, but also some other prerequisites.</description></item><item><title>Configuration via Services</title><link>/docs/reference/configuration-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/reference/configuration-services/</guid><description>Langium supports the configuration of most aspects of your language and language server via a set of services. Those services are configured by modules, which are essentially mappings from a service name to its implementation.
We can separate services and modules into two main categories:
Shared Services The shared services are services that are shared across all Langium languages. In many applications there is only one Langium language, but the overall structure of the services is the same.</description></item><item><title>Features</title><link>/docs/features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/features/</guid><description>Designing programming languages from the ground up is hard, independent of whether your language is a &amp;ldquo;simple&amp;rdquo; domain specific language or a full-fledged general-purpose programming language. Not only do you have to keep up with the requirements of your domain experts, but you have to deal with all the technical complexity that comes with building a language, including questions such as:
How do I get from a string to a semantic model which I can work with?</description></item><item><title>2. Scaffold a Langium project</title><link>/docs/learn/workflow/scaffold/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/workflow/scaffold/</guid><description>To create your first working DSL, execute the Yeoman generator:
&amp;gt; yo langium ┌─────┐ ─┐ ┌───┐ │ ╶─╮ ┌─╮ ╭─╮ ╷ ╷ ╷ ┌─┬─╮ │ ,´ │ ╭─┤ │ │ │ │ │ │ │ │ │ │ │╱ ╰─ ╰─┘ ╵ ╵ ╰─┤ ╵ ╰─╯ ╵ ╵ ╵ ` ╶─╯ Welcome to Langium! This tool generates a VS Code extension with a &amp;quot;Hello World&amp;quot; language to get started quickly. The extension name is an identifier used in the extension marketplace or package registry.</description></item><item><title>Arithmetics</title><link>/showcase/arithmetics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/arithmetics/</guid><description/></item><item><title>Document Lifecycle</title><link>/docs/reference/document-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/reference/document-lifecycle/</guid><description>LangiumDocument is the central data structure in Langium that represents a text file of your DSL. Its main purpose is to hold the parsed Abstract Syntax Tree (AST) plus additional information derived from it. After its creation, a LangiumDocument must be &amp;ldquo;built&amp;rdquo; before it can be used in any way. The service responsible for building documents is called DocumentBuilder.
A LangiumDocument goes through seven different states during its lifecycle:
Parsed when an AST has been generated from the content of the document.</description></item><item><title>Formatting</title><link>/docs/recipes/formatting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/recipes/formatting/</guid><description>Masale&amp;rsquo;s formatting API allows to easily create formatters for your language. We start building a custom formatter for our language by creating a new class that inherits from AbstractFormatter.
import { AbstractFormatter, AstNode, Formatting } from 'langium'; export class CustomFormatter extends AbstractFormatter { protected format(node: AstNode): void { // This method is called for every AstNode in a document } } ... // Bind the class in your module export const CustomModule: Module&amp;lt;CustomServices, PartialLangiumServices&amp;gt; = { lsp: { Formatter: () =&amp;gt; new CustomFormatter() } }; The entry point for the formatter is the abstract format(AstNode) method.</description></item><item><title>MiniLogo</title><link>/showcase/minilogo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/minilogo/</guid><description/></item><item><title>Showcases</title><link>/docs/introduction/showcases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/introduction/showcases/</guid><description/></item><item><title>State Machine</title><link>/showcase/statemachine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/statemachine/</guid><description/></item><item><title>3. Write the grammar</title><link>/docs/learn/workflow/write_grammar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/workflow/write_grammar/</guid><description>Your Langium project is now setup and ready to be used. The next step is to define the grammar of your language. The grammar is the most important part of your language definition. It defines the syntax of your language and how the language elements are structured.
The grammar is defined in a .langium file. Make sure that you have installed the VS Code extension for Langium. This extension provides syntax highlighting and code completion for .</description></item><item><title>Multiple dependent languages</title><link>/docs/recipes/multiple-languages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/recipes/multiple-languages/</guid><description>This guide is about integrating multiple dependent languages in one Langium project.
One common situation where it makes sense to create dependent languages is when you only want to read concepts in one language and predefine them in another file (probably also a built-in one). Think of splitting SQL into a defining CREATE TABLE table (...)) and a reading part (SELECT * FROM table).
Notice that for n independent languages, you can simply create n independent Langium projects.</description></item><item><title>Semantic Model Inference</title><link>/docs/reference/semantic-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/reference/semantic-model/</guid><description>When AST nodes are created during the parsing of a document, they are given a type. The language grammar dictates the shape of those types and how they might be related to each other. All types form the semantic model of your language. There are two ways by which Langium derives semantic model types from the grammar, by inference and by declaration.
Inference is the default behavior in Langium. During the generation of the semantic model types, Langium infers the possible types directly from the grammar rules.</description></item><item><title>SQL</title><link>/showcase/sql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/sql/</guid><description/></item><item><title>Try it out!</title><link>/docs/introduction/playground/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/introduction/playground/</guid><description/></item><item><title>4. Generate the AST</title><link>/docs/learn/workflow/generate_ast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/workflow/generate_ast/</guid><description>After defining the grammar, you can generate the abstract syntax tree (AST) of your language. The AST is a tree representation of the source code that can be used to analyze and transform the code. The AST definition is generated by the Langium CLI. Simply call the following command on your terminal:
npm run langium:generate This line will call langium generate on your Langium project. The Langium CLI will generate the files in the src/generated directory.</description></item><item><title>Domain Model</title><link>/showcase/domainmodel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/domainmodel/</guid><description/></item><item><title>5. Resolve cross-references</title><link>/docs/learn/workflow/resolve_cross_references/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/workflow/resolve_cross_references/</guid><description>This step takes place after generating the AST. The AST definition was created and you are able to parse input files. But the AST is not complete yet. It contains cross-references that are not resolved. Cross-references are used to reference other elements in your language.
Problem Let&amp;rsquo;s illustrate the problem using the Hello-World example from the Yeoman generator:
person John person Jane Hello John! Hello Jane! The following syntax tree is generated by the Langium parser during the runtime.</description></item><item><title>6. Create validations</title><link>/docs/learn/workflow/create_validations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/workflow/create_validations/</guid><description>After resolving the cross-references, you can assume that the syntax tree is complete. Now you can start with the validation of the input files. The validation process is a crucial part of the language engineering workflow. The parser ensures the syntactic correctness of the input files. The validation process ensures the semantic correctness of the input files.
Example Let&amp;rsquo;s consider the Hello-World example from the Yeoman generator. One semantic of this language could be that each declared person must be greeted at most once.</description></item><item><title>7. Generate artifacts</title><link>/docs/learn/workflow/generate_everything/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/workflow/generate_everything/</guid><description>The syntax was ensured. The semantics were checked. Your workspace is free of errors. Now the AST is a valid representation of your input file written in your language. It is time to generate some cool stuff!
Depending on your domain and on your requirements there are different ways to generate artifacts from your AST.
How to write the generator? The simplest way is to generate text into a string.</description></item><item><title>Code Bundling</title><link>/docs/recipes/code-bundling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/recipes/code-bundling/</guid><description>When you first create a Langium project using the Yeoman generator, it will only contain a plain TypeScript configuration, without any additional build processes. However, if you want to make your language available for consumption in a non-development context, you&amp;rsquo;ll want to create a bundle. It is not absolutely necessary in a Node.js context, since you can always resolve local node_modules but it&amp;rsquo;s still recommended for vscode extensions. It improves performance and decreases file size by minifying your code and only including what you actually need.</description></item><item><title>OpenAPI SL</title><link>/showcase/openapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/openapi/</guid><description/></item><item><title>Writing a Grammar</title><link>/docs/learn/minilogo/writing_a_grammar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/learn/minilogo/writing_a_grammar/</guid><description>Planning Sketching the Grammar Adding Commands Adding Expressions Adding Terminals In this tutorial we will be talking about writing a grammar for your language in Langium. As a motivating example, we&amp;rsquo;ll be describing how to write a grammar for the MiniLogo language. If you&amp;rsquo;re not familiar with MiniLogo, it&amp;rsquo;s a smaller implementation of the Logo programming language. Logo itself is a lot like Turtle from Python.</description></item></channel></rss>